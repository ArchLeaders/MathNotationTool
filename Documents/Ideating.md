# Programming 11 - Ideating

### What can you do to mitigate the boundaries and limiting factors you identified with regards to your design space?

There are very few limitations with my design, but one of great importance is time, which can only be mitigated by being more focused and time efficient. To achieve this time efficiency while working on many different projects as well, I set goals for myself with general criteria and completion dates. Another limiting factor would be, of course, my knowledge and experience; with this, I am very grateful for online resources where I have been able to hone and practice my skills, and the programming experience of my father to consult over any questions I may have.

<br>

## What have other people created? What can you change in other designs to make a new design?

I have not currently found any *"designs"* that are quite what I have in mind for this project. But, in general, making a new design from an existing one depends on what you're making, who your audience is, and how your idea differs from another's design. In some cases, building off of an existing project can be desirable in that it enhances the original product by adding better functionality and new features. For this project, it seemed better to start my design from scratch, while still using the tools and libraries provided by the community to complete my design.

<br>

## How do competing social, ethical, and sustainability considerations impact design solutions to meet global needs for optimal future living?

Most of my personal/community projects have little impact from these considerations. And concerns in corporation-level work have been handled by the company well before production in my experience.

<br>

## Consider the list of your design ideas. How will you prioritize which ideas to work with users to design and prototype?

For this project I considered three design ideas:

- **Idea #1:** *Node-based editor with simplified controls to mimic code instructions that can be executed to perform simple math functions.*
- **Idea #2:** *Simple text editor using a C-like lexical analysis and support similar instructions that can be executed.*
- **Idea #3:** *Similar text editor (possibly without execute features), but with an attached calculator interface for simple math functions.*

I chose to go with my third concept because it held a good balance of profit to production time. Option one would have yielded the most users, but would have been far more time-consuming to implement. Option two would be the easiest to implement, but also somewhat restrictive to less advanced users. This leaves the third option, which would appeal to a range of general to advanced users, and be easy enough to implement to still make a good profit.